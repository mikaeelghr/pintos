# تمرین گروهی ۱.۱ - مستند طراحی

گروه
-----
 > نام و آدرس پست الکترونیکی اعضای گروه را در این قسمت بنویسید.

حمیدرضا کلباسی <hamidrezakalbasi@protonmail.com>

مهدی جعفری <mahdi.jfri.79@gmail.com>

میکائیل قربانی <mikaeelghr@gmail.com>

یاسین نوران <ynooran@gmail.com>

مقدمات
----------
> اگر نکات اضافه‌ای در مورد تمرین یا برای دستیاران آموزشی دارید در این قسمت  بنویسید.

> لطفا در این قسمت تمامی منابعی (غیر از مستندات Pintos، اسلاید‌ها و دیگر منابع درس) را که برای تمرین از آن‌ها استفاده کرده‌اید در این قسمت بنویسید.

پاس‌دادن آرگومان
============
داده‌ساختار‌ها و توابع
----------------
> در این قسمت تعریف هر یک از `struct` ها، اعضای `struct` ها، متغیرهای سراسری یا ایستا، `typedef` ها یا `enum` هایی که ایجاد کرده‌اید یا تغییر داده‌اید را بنویسید و دلیل هر کدام را در حداکثر ۲۵ کلمه توضیح دهید.

/*
این تابع آرگومان های مین را درون استک قرار می دهد و سپس استک پوینتر را تنظیم می کند تا 
به انتهانی این چیز های قرار داده شده در استک اشاره کند.

اگر این تابع ناموفق باشد، خروجی آن فالس خواهد بود.
*/
bool put_main_arguments_in_stack(void** esp, int argc, char* argv[])

/*
این تابع ورودی فایل نیم را تبدیل به آرایه خواسته شده برای پاس دادن به تابع مین می کند و خروجی
ها را در پوینتر های ورودی دو و سه می ریزد.

اگر این تابع ناموفق باشد، خروجی آن فالس خواهد بود.
*/
bool split_command_to_argv(char *command, int* argc, char **argv[]);


الگوریتم‌ها
------------
> به‌طور خلاصه توضیح دهید چگونه آرگومان‌ها را پردازش کرده‌اید؟ چگونه اعضای `argv[]` را به ترتیب درست در پشته قرار داده‌اید؟ و چگونه از سرریز پشته جلوگیری کرده‌اید؟

آرگومان ها را درون تابع
split_command_to_argv
به کمک تابع
strtok_r
تبدیل می کنیم و ارگ سی و ارگ وی را به دست می آوریم. سپس تابع
put_main_arguments_in_stack
پارامتر ها را به ترتیب برعکس درون پشته قرار می دهد و مقدار استک پوینتر را به اندازه لازم
پایین می آورد. قبل از این که این کار انجام شود اندازه لازم برای این کار به دست می آید و اگر
بیشتر از اندازه یک پیج بود، خروجی تابع
put_main_arguments_in_stack
فالس خواهد بود.

منطق طراحی
-----------------
> چرا Pintos به‌جای تابع‌ `strtok()` تابع‌ `strtok_r()` را پیاده‌سازی کرده‌است؟

به این دلیل که تابع
strtok
یک تابع ناامن در محیط های هم روند است و چون در یک متغیر گلوبال تاریخچه را نگه می دارد
هنگامی که چند ترد از این تابع استفاده کنند به مشکل خواهیم خورد.

> در Pintos عمل جدا کردن نام فایل از آرگومان‌ها، در داخل کرنل انجام می‌شود. در سیستم عامل‌های برپایه‌ی Unix، این عمل توسط shell انجام می‌شود. حداقل دو مورد از برتری‌های رویکرد Unix را توضیح دهید.

۱. هرچه کرنل کوچک تر باشد احتمال وجود باگ در آن کمتر است و خطرات آن کمتر خواهد شد
۲. طبق فلسفه یونیکس، این موضوع وظیفه هسته نیست بلکه وظیفه شل است و وقتی لایه انتزاعی هسته
بالاتر باشد می توان روش های دیگری را نیز جدای از روش شل برای اجرای برنامه ها به کار گرفت.

فراخوانی‌های سیستمی
================
داده‌ساختار‌ها
----------------
> در این قسمت تعریف هر یک از `struct` ها، اعضای `struct` ها، متغیرهای سراسری یا ایستا، `typedef` ها یا `enum` هایی که ای.جاد کرده‌اید یا تغییر داده‌اید را بنویسید و دلیل هر کدام را در حداکثر ۲۵ کلمه توضیح دهید.

int is_pointer_valid(void **pointer);
int is_esp_valid(void **esp);

struct file_descriptor {
    int fd;
    struct list_elem elem;  
    struct file *file;
};

به استراکت ترد در فایل
thread.h
این فیلد ها را برای مدیریت فایل ها اضافه می کنیم:

struct list file_descriptors;
struct semaphore waiter;

> توضیح دهید که توصیف‌کننده‌های فایل چگونه به فایل‌های باز مربوط می‌شوند. آیا این توصیف‌کننده‌ها در کل سیستم‌عامل به‌طور یکتا مشخص می‌شوند یا فقط برای هر پردازه یکتا هستند؟

هر توصیف کننده توسط استراکت فایل دسکریپتور به فایل واقعی ای که باز کرده است مرتبط می شود و هر
پراسس (که در پینتوس معادل یک ترد در کرنل است) توسط لیستی که درونش قرار دارد به فایل دیسکریپتور
های متعلق به خودش مرتبط می شود. فایل دیسکریپتور ها در یک پردازه یکتا هستند و لزومی ندارد که
در کل سیستم عامل یکتا باشند.

الگوریتم‌ها
------------
> توضیح دهید خواندن و نوشتن داده‌های کاربر از داخل هسته، در کد شما چگونه انجام شده است.

به وسیله تابع
is_esp_valid
چک می کنیم که استک پوینتر کاربر معتبر باشد و در اختیار خودش باشد. سپس پارامتر های سیستم کال
را از روی استک بر می داریم و چک می کنیم که اگر پارامتر ها خودشان شرایط خاصی دارند (مثلا
خودشان پوینتر هستند) معتبر باشند و سپس سیستم کال را اجرا می کنیم و خروجی را روی استک
کاربر می نویسیم.

> فرض کنید یک فراخوانی سیستمی باعث شود یک صفحه‌ی کامل (۴۰۹۶ بایت) از فضای کاربر در فضای هسته کپی شود. بیشترین و کمترین تعداد بررسی‌‌های جدول صفحات
(page table)
چقدر است؟ (تعداد دفعاتی که
`pagedir_get_page()`
صدا زده می‌شود.)
در‌ یک فراخوانی سیستمی که فقط ۲ بایت کپی می‌شود چطور؟ آیا این عددها می‌توانند بهبود یابند؟ چقدر؟

در هر دو حالت (هم ۴۰۹۶ و هم ۲ بایت) ممکن است این اطلاعات درون یک پیج یا بین دو پیج قرار داشته باشند
که در بهترین حالت ۱ و حداکثر ۲ پیج باید کپی شود. می توان به کمک الاینمنت
این اعداد را بهبود داد به طوری که تنها به کپی کردن یک پیج نیاز باشد.

> پیاده‌سازی فراخوانی سیستمی
`wait`
را توضیح دهید و بگویید چگونه با پایان یافتن پردازه در ارتباط است.

هنگام ایجاد یک پراسس، یک سمافور مخصوص برایش را مقدار دهی اولیه صفر می کنیم. در سیستم کال ویت، ابتدا
چک می کنیم که پراسس با آی دی مد نظر وجود داشته باشد
و تمام نشده باشد (مقدار اگزیتد آن فالس باشد) و در این صورت سمافور داون را روی سمافور
ترد مورد نظر صدا می کنیم. هنگام خروج از هر ترد، 
اگزیتد آن را ترو می کنیم سپس سمافور آن را تعداد بار ثابتی آپ می کنیم تا همه
پراسس ها / کرنل که روی آن
ویت کرده اند بیدار شوند.

> هر دستیابی هسته به حافظه‌ی برنامه‌ی کاربر، که آدرس آن را کاربر مشخص کرده است، ممکن است به دلیل مقدار نامعتبر اشاره‌گر منجر به شکست شود. در این صورت باید پردازه‌ی کاربر خاتمه داده شود. فراخوانی های سیستمی پر از چنین دستیابی‌هایی هستند. برای مثال فراخوانی سیستمی
`write‍`
نیاز دارد ابتدا شماره‌ی فراخوانی سیستمی را از پشته‌ی کاربر بخواند، سپس باید سه آرگومان ورودی و بعد از آن مقدار دلخواهی از حافظه کاربر را (که آرگومان ها به آن اشاره می کنند) بخواند. هر یک از این دسترسی ها به حافظه ممکن است با شکست مواجه شود. بدین ترتیب با یک مسئله‌ی طراحی و رسیدگی به خطا
(error handling)
مواجهیم. بهترین روشی که به ذهن شما می‌رسد تا از گم‌شدن مفهوم اصلی کد در بین شروط رسیدگی به خطا جلوگیری کند چیست؟ همچنین چگونه بعد از تشخیص خطا، از آزاد شدن تمامی منابع موقتی‌ای که تخصیص داده‌اید (قفل‌ها، بافر‌ها و...) مطمئن می‌شوید؟ در تعداد کمی پاراگراف، استراتژی خود را برای مدیریت این مسائل با ذکر مثال بیان کنید.

قبل از هر دسترسی با استفاده از تابع
is_pointer_valid
چک می کنیم که 

همگام‌سازی
---------------
> فراخوانی سیستمی
`exec`
نباید قبل از پایان بارگذاری فایل اجرایی
برگردد، چون در صورتی که بارگذاری
فایل اجرایی با خطا مواجه شود باید `-۱` برگرداند. کد شما چگونه از این موضوع اطمینان حاصل می‌کند؟ چگونه وضعیت موفقیت یا شکست در اجرا به ریسه‌ای که
`exec`
را فراخوانی کرده اطلاع داده می‌شود؟

پراسسی که فراخوانی سیستمی را انجام داده است را تا
پایان کار بلاک نگه می داریم و اگر به خطا برخوردیم با
خروجی منفی یک به او اجازه ادامه می دهیم و در غیر این صورت با پایان لود فایل اجرایی در حافظه
کار را به صورت عادی ادامه می دهیم

> پردازه‌ی والد
P
و پردازه‌ی فرزند
C
را درنظر بگیرید. هنگامی که
P
فراخوانی
`wait(C)`
را اجرا می‌کند و
C
هنوز خارج نشده است، توضیح دهید که چگونه همگام‌سازی مناسب را برای جلوگیری از ایجاد شرایط مسابقه
(race condition)
پیاده‌سازی کرده‌اید. وقتی که
C
از قبل خارج شده باشد چطور؟ در هر حالت چگونه از آزاد شدن تمامی منابع اطمینان حاصل می‌کنید؟ اگر
P
بدون منتظر ماندن، قبل از
C
خارج شود چطور؟ اگر بدون منتظر ماندن بعد از
C
خارج شود چطور؟ آیا حالت‌های خاصی وجود دارد؟

به علت این که ما از سمافور استفاده کرده ایم ریس کاندیشن نداریم. کرنل یک بار سمافور هر ترد را
داون می کند تا هنگامی که پراسس به پایان رسید کرنل که سمافور پراسس را داون کرده بود اجرا
می شود و منابع آن ترد را آزاد می کند و از لیست ترد ها حذف می کند. اگر بخواهیم روی یک ترد
حذف شده ویت کنیم چون در لیست ترد ها نیست با شکست به کار خود ادامه می دهیم. باید به این نکته
توجه کنیم که هنگام کار روی لیست ترد ها از یک قفل استفاده کنیم تا به دیتا ریس نخوریم.

منطق طراحی
-----------------
> به چه دلیل روش دسترسی به حافظه سطح کاربر از داخل هسته را این‌گونه پیاده‌سازی کرده‌اید؟

چون کرش نکردن کرنل برای ما اهمیت دارد، باید این قسمت از کد در برابر کاربر مخرب یا نادان
ایمن باشد و بنابراین اگرچه چک کردن پوینتر ها در همه جا ممکن است زمان زیادی بگیرد اما
به آن نیاز داریم.

> طراحی شما برای توصیف‌کننده‌های فایل چه نقاط قوت و ضعفی دارد؟

چون توصیف کننده های فایل برای هر پراسس در یک لیست مجزا قرار دارند دسترسی به آن ها سریع و مستقل
از پراسس های دیگر است که یک نقطه قوت به حساب می آید. اما دسترسی به همه توصیف کننده های مربوط به یک فایل کند است زیرا باید
برای همه پراسس ها این بررسی را انجام دهیم و عملا روی تمام توصیف کننده ها فور بزنیم که یک
نقطه ضعف به حساب می آید.

> در حالت پیش‌فرض نگاشت
`tid` به `pid`
یک نگاشت همانی است. اگر این را تغییر داده‌اید، روی‌کرد شما چه نقاط قوتی دارد؟

این رویکرد را تغییر نداده ایم.

سوالات افزون بر طراحی
===========
> تستی را که هنگام اجرای فراخوانی سیستمی از یک اشاره‌گر پشته‌ی
(esp)
نامعتبر استفاده کرده است بیابید. پاسخ
شما باید دقیق بوده و نام تست و چگونگی کارکرد آن را شامل شود.

تست
sc-bad-arg
که در آن مقدار استک پوینتر به یک جای نامعلوم تنظیم می شود و سپس اینتراپت شماره ۳۰ که همان
سیستم کال است اجرا می شود.

> تستی را که هنگام اجرای فراخوانی سیستمی از یک اشاره‌گر پشته‌ی معتبر استفاده کرده ولی اشاره‌گر پشته آنقدر به مرز صفحه نزدیک است که برخی از آرگومان‌های فراخوانی سیستمی در جای نامعتبر مموری قرار گرفته اند مشخص کنید. پاسخ شما باید دقیق بوده و نام تست و چگونگی کارکرد آن را شامل شود.یک قسمت از خواسته‌های تمرین را که توسط مجموعه تست موجود تست نشده‌است، نام ببرید. سپس مشخص کنید تستی که این خواسته را پوشش بدهد چگونه باید باشد.

تست
exec-bound-3
که در آن یک رشته به مرز پیج نزدیک است به طوری که کل رشته درون پیج است اما کاراکتر صفر
آخر رشته از پیج بیرون زده است به همین دلیل سیستم کال باید از اجرای برنامه جلوگیری کند.

سیستم کال اگزک نباید اگر هنگام لود کردن فایل به مشکلی می خوردیم به درستی اجرا شود و باید
همان گونه که در داک مطرح شد منفی ۱ برگرداند که این مطلب تست نشده است. برای تست این مطلب
می توانیم یک فایل بسیار بزرگ را تلاش به اجرا کنیم و چون این فایل در رم جا نمی شود به مشکل
خواهد خورد و باید منفی یک به برنامه کاربر برگردانده شود.


سوالات نظرخواهی
==============
پاسخ به این سوالات اختیاری است، ولی پاسخ به آن‌ها می‌تواند به ما در بهبود درس در ترم‌های آینده کمک کند. هر چه در ذهن خود دارید بگویید. این سوالات برای دریافت افکار شما هستند. هم‌چنین می‌توانید پاسخ خود را به صورت ناشناس در انتهای ترم ارائه دهید.

> به نظر شما، این تمرین یا هر یک از سه بخش آن، آسان یا سخت بودند؟ آیا وقت خیلی کم یا وقت خیلی زیادی گرفتند؟

> آیا شما بخشی را در تمرین یافتید که دید عمیق‌تری نسبت به طراحی سیستم عامل به شما بدهد؟

> آیا مسئله یا راهنمایی خاصی وجود دارد که بخواهید برای حل مسائل تمرین به دانشجویان ترم‌های آینده بگویید؟

در بخش ۱۴ تمرین یک صفر راهنمایی بیشتری لازم است.

> آیا توصیه‌ای برای دستیاران آموزشی دارید که چگونه دانشجویان را در ترم‌های آینده یا در ادامه‌ی ترم بهتر یاری کنند؟

> اگر نظر یا بازخورد دیگری دارید در این قسمت بنویسید.