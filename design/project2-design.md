# سیستم‌های عامل - تمرین گروهی دوم

## مشخصات گروه

>> نام، نام خانوادگی و ایمیل خود را در ادامه وارد کنید.

حمیدرضا کلباسی <hamidrezakalbasi@protonmail.com>

مهدی جعفری <mahdi.jfri.79@gmail.com>

میکائیل قربانی <mikaeelghr@gmail.com>

یاسین نوران <ynooran@gmail.com>

## مقدمه

>> اگر نکته‌ای درباره فایل‌های سابمیت شده یا برای TAها دارید، لطفا اینجا بیان کنید.

>> اگر از هر منبع برخط یا غیر برخطی به غیر از مستندات Pintos، متن درس، اسلایدهای درس یا نکات گفته شده در کلاس در تمرین گروهی استفاده کرده‌اید، لطفا اینجا آن(ها) را ذکر کنید.

## ساعت زنگ‌دار

### داده ساختارها

>> پرسش اول: تعریف `struct`های جدید، `struct`های تغییر داده شده، متغیرهای گلوبال یا استاتیک، `typedef`ها یا `enumeration`ها را در اینجا آورده و برای هریک در 25 کلمه یا کمتر توضیح بنویسید.

```

static struct list sleep_list;

```


لیست کسانی که در انتظار تایمر هستند. این لیست بر اساس زمان بیداری مرتب شده است.

در استراکت ترد:

```

int64_t wake_time;

struct list_elem sleep_elem;

```


زمان بیداری و آبجکت متناظر `sleep_list`

### الگوریتم

>> پرسش دوم: به اختصار آن‌چه هنگام صدا زدن تابع `timer_sleep()` رخ می‌دهد و همچنین اثر `timer interrupt handler` را توضیح دهید.

در این تابع ابتدا اینتراپت ها غیرفعال می شوند، سپس ترد به لیست خواب اضافه می شود و در `timer interrupt handler` عضو اول لیست خواب را بررسی می کنیم و اگر زمان بیداری اش رسیده بود، آن را به لیست آماده اضافه می کنیم و به سراع عضو بعدی از لیست خواب می رویم. 

>> پرسش سوم: مراحلی که برای کوتاه کردن زمان صرف‌شده در `timer interrupt handler` صرف می‌شود را نام ببرید.

چون لیست خواب مرتب شده است اینتراپت هندلر تنها در موقع مورد نیاز کار اضافه می کند و در مجموع از `O(1)` است.

### همگام‌سازی

>> پرسش چهارم: هنگامی که چند ریسه به طور همزمان `timer_sleep()` را صدا می‌زنند، چگونه از `race condition` جلوگیری می‌شود؟

با غیرفعال کردن اینتراپت ها از این مساله جلوگیری می شود.

>> پرسش پنجم: هنگام صدا زدن `timer_sleep()` اگر یک وقفه ایجاد شود چگونه از `race condition` جلوگیری می‌شود؟

با غیرفعال کردن اینتراپت ها از این مساله جلوگیری می شود.

### منطق

>> پرسش ششم: چرا این طراحی را استفاده کردید؟ برتری طراحی فعلی خود را بر طراحی‌های دیگری که مدنظر داشته‌اید بیان کنید.

چون زمان صرف شده در  `timer interrupt handler` بسیار سریع است و غیرفعال کردن اینتراپت ها از هرگونه مشکل همگام سازی جلوگیری می کند.

## زمان‌بند اولویت‌دار

### داده ساختارها

>> پرسش اول: تعریف `struct`های جدید، `struct`های تغییر داده شده، متغیرهای گلوبال یا استاتیک، `typedef`ها یا `enumeration`ها را در اینجا آورده و برای هریک در ۲۵ کلمه یا کمتر توضیح بنویسید.

>> پرسش دوم: داده‌ساختارهایی که برای اجرای `priority donation` استفاده شده‌است را توضیح دهید. (می‌توانید تصویر نیز قرار دهید)

در استراکت ترد:

```

struct thread* priority_donator;

```


### الگوریتم

>> پرسش سوم: چگونه مطمئن می‌شوید که ریسه با بیشترین اولویت که منتظر یک قفل، سمافور یا `condition variable` است زودتر از همه بیدار می‌شود؟

صبر کننده های هر سمافور و هر `condition variable` را به ترتیب اولویت مرتب می کنیم. (قفل خودش هنگام بیدار شدن از سمافور استفاده می کند)

>> پرسش چهارم: مراحلی که هنگام صدازدن `lock_acquire()` منجر به `priority donation` می‌شوند را نام ببرید. دونیشن‌های تو در تو چگونه مدیریت می‌شوند؟

اینتراپت ها را غیرفعال می کنیم. بررسی می کنیم که `NULL==holder` نباشد و اولویتش از ما کمتر باشد. در این صورت اولویت خود را به او اهدا می کنیم و سپس ادامه کار به صورت عادی انجام می شود. (بدون فعال کردن اینتراپت ها)

روال اهدا به این صورت است که فرض کنید الف می خواهد اولویت خود را به ب بدهد. واضح است که الف در وضعیت اجرا است. اشاره گر اهدا کننده ب را روی الف تنظیم می کنیم. به علاوه اگر ب خودش اولویتش را از پ گرفته بود، اولویت پ را به الف تخصیص می دهیم. حال اگر ب در صف آماده ها باشد، اولویت خود را با ب عوض می کنیم و ب را به اول صف می آوریم. (چون الف در حال اجراست، یعنی بیشترین اولویت را داشته است.) در غیر این صورت ب در وضعیت `blocked` است و در یک لیست انتظار وجود دارد. اگر این لیست انتظار برای زمان نبود، (یعنی برای یک قفل مانند بود) اولویت الف را مثل بالا با ب تعویض می کنیم و سپس ب را در آن لیست جا به جا می کنیم تا لیست دوباره مرتب شود. 

>> پرسش پنجم: مراحلی که هنگام صدا زدن `lock_release()` روی یک قفل که یک ریسه با اولویت بالا منتظر آن است، رخ می‌دهد را نام ببرید.

هنگام آزاد کردن یک قفل، اگر اهدا کننده ای به ما وجود داشت (که از نال نبودن اشاره گر معلوم می شود) اولویتش را به او پس می دهیم. میدانیم که آن ترد منتظر قفل آزاد شده ی ماست. پس او را به اول صف میاوریم و سپس مانند قبل قفل را آزاد میکنیم.

### همگام‌سازی

>> پرسش ششم: یک شرایط احتمالی برای رخداد `race condition` در `thread_set_priority` را بیان کنید و توضیح دهید که چگونه پیاده‌سازی شما از رخداد آن جلوگیری می‌کند. آیا می‌توانید با استفاده از یک قفل از رخداد آن جلوگیری کنید؟

مثلا همزمان یکی بخواهد به دارنده قفل اولویتش را اهدا کند و دارنده بخواهد اولویتش را زیاد کند. ما در پیاده سازی خود هنگام کار با اولویت ها به طور کلی اینتراپت ها را غیر فعال می کنیم. استفاده از یک قفل مقدور نیست به علت این که هنگام استفاده از قفل، یک اهدای اولویت دیگر ممکن است انجام شود.

### منطق

>> پرسش هفتم: چرا این طراحی را استفاده کردید؟ برتری طراحی فعلی خود را بر طراحی‌های دیگری که مدنظر داشته‌اید بیان کنید.

چون پیچیدگی آن کم است و سرعت آن به نسبت پیچیدگی مناسب است.

## سوالات افزون بر طراحی

>> پرسش هشتم: در کلاس سه صفت مهم ریسه‌ها که سیستم عامل هنگامی که ریسه درحال اجرا نیست را ذخیره می‌کند، بررسی کردیم:‍‍ `program counter` ، ‍‍‍`stack pointer` و `registers`. بررسی کنید که این سه کجا و چگونه در `Pintos` ذخیره می‌شوند؟ مطالعه ‍`switch.S` و تابع ‍`schedule` در فایل `thread.c` می‌تواند مفید باشد.
رجیستر های عادی درون استک خود ترد ذخیره می شوند و سپس `stack pointer`  درون خود ترد که در ابتدای استک خود است، ذخیره می شود. سپس استک تردی که می خواهیم به آن سوییچ کنیم را تنظیم می کند و هنگامی که `ret` صدا می شود، خود به خود به محل قبلی باز می گردد و نیازی به بررسی دستی `program counter` نداریم.

>> پرسش نهم: وقتی یک ریسه‌ی هسته در ‍`Pintos` تابع `thread_exit` را صدا می‌زند، کجا و به چه ترتیبی صفحه شامل پشته و `TCB` یا `struct thread` آزاد می‌شود؟ چرا این حافظه را نمی‌توانیم به کمک صدازدن تابع ‍`palloc_free_page` داخل تابع ‍`thread_exit` آزاد کنیم؟

وقتی که سوییچ به طور کامل انجام شد، بررسی می شود که اگر ترد قبلی در وضعیت در حال مردن بود، حافظه آن را آزاد می کند. این حافظه نمی تواند در `thread_exit` آزاد شود چون در هنگام سوییچ به اطلاعات آن نیاز داریم.

>> پرسش دهم: زمانی که تابع ‍`thread_tick` توسط `timer interrupt handler` صدا زده می‌شود، در کدام پشته اجرا می‌شود؟

در پشته تردی که قبل از اینتراپت تایمر در حال اجرا بوده است.

>> پرسش یازدهم: یک پیاده‌سازی کاملا کاربردی و درست این پروژه را در نظر بگیرید که فقط یک مشکل درون تابع ‍`sema_up()` دارد. با توجه به نیازمندی‌های پروژه سمافورها(و سایر متغیرهای به‌هنگام‌سازی) باید ریسه‌های با اولویت بالاتر را بر ریسه‌های با اولویت پایین‌تر ترجیح دهند. با این حال پیاده‌سازی ریسه‌های با اولویت بالاتر را براساس اولویت مبنا `Base Priority` به جای اولویت موثر ‍`Effective Priority` انتخاب می‌کند. اساسا اهدای اولویت زمانی که سمافور تصمیم می‌گیرد که کدام ریسه رفع مسدودیت شود، تاثیر داده نمی‌شود. تستی طراحی کنید که وجود این باگ را اثبات کند. تست‌های `Pintos` شامل کد معمولی در سطح هسته (مانند متغیرها، فراخوانی توابع، جملات شرطی و ...) هستند و می‌توانند متن چاپ کنند و می‌توانیم متن چاپ شده را با خروجی مورد انتظار مقایسه کنیم و اگر متفاوت بودند، وجود مشکل در پیاده‌سازی اثبات می‌شود. شما باید توضیحی درباره این که تست چگونه کار می‌کند، خروجی مورد انتظار و خروجی واقعی آن فراهم کنید.

چهار ترد داریم.
ترد آ: اولویت اولیه ۱
ترد ب: اولویت اولیه ۲
ترد پ: اولویت اولیه ۳
ترد ث: اولویت اولیه ۴

ترد آ در ابتدا وارد شده و قفل ۱ را میگیرد و به خواب زمانی طولانی میرود.
ترد ب وارد شده و قفل ۲ را میگیرد و قفل ۱ را درخواست میکند. اولویت خود را به آ میدهد. اما آ در خواب زمانیست.
ترد پ وارد شده و قفل ۱ را درخواست میکند. اولویت خود را به آ میدهد. اما آ در خواب زمانیست.
ترد ث وارد میشود و قفل ۲ را درخواست میکند. اولویت خود را به ب میدهد. ب سپس این اولویت را به آ میدهد.
آ از خواب زمانی بیدار شده و کار خود را انجام میدهد و به `release_lock` میرسد.
ابتدا آ اولویت‌ها را برگردانده و در این لحظه اولویت ب برابر ۴، اولویت پ برابر ۳، اولویت ث ۲ است. 
آ باید قفل ۱ را به ب بدهد، اما به علت مشکل خود به پ میدهد. سپس پ تمام میشود و قفل ۱ را به ب میدهد. سپس ب تمام میشود و قفل ۲ را به ث میدهد. سپس ث تمام میشود.

کافیست در حین اتمام هر ترد یک متن چاپ کنیم تا اشتباه مشخص شود. در حالت کد اشتباه ترتیب آ پ ب ث است. اما در حالت درست ترتیب آ ب ث پ خواهد بود.

## سوالات نظرسنجی

پاسخ به این سوالات دلخواه است، اما به ما برای بهبود این درس در ادامه کمک خواهد کرد. نظرات خود را آزادانه به ما بگوئید—این سوالات فقط برای سنجش افکار شماست. ممکن است شما بخواهید ارزیابی خود از درس را به صورت ناشناس و در انتهای ترم بیان کنید.

>> به نظر شما، این تمرین گروهی، یا هر کدام از سه وظیفه آن، از نظر دشواری در چه سطحی بود؟ خیلی سخت یا خیلی آسان؟

>> چه مدت زمانی را صرف انجام این تمرین کردید؟ نسبتا زیاد یا خیلی کم؟

>> آیا بعد از کار بر روی یک بخش خاص از این تمرین (هر بخشی)، این احساس در شما به وجود آمد که اکنون یک دید بهتر نسبت به برخی جنبه‌های سیستم عامل دارید؟

>> آیا نکته یا راهنمایی خاصی وجود دارد که بهتر است ما آنها را به توضیحات این تمرین اضافه کنیم تا به دانشجویان ترم های آتی در حل مسائل کمک کند؟

>> متقابلا، آیا راهنمایی نادرستی که منجر به گمراهی شما شود وجود داشته است؟

>> آیا پیشنهادی در مورد دستیاران آموزشی درس، برای همکاری موثرتر با دانشجویان دارید؟

این پیشنهادات میتوانند هم برای تمرین‌های گروهی بعدی همین ترم و هم برای ترم‌های آینده باشد.

>> آیا حرف دیگری دارید؟
