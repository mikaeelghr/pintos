تمرین گروهی ۳ - مستند طراحی

======================

گروه

-----

>>‫نام و آدرس پست الکترونیکی اعضای گروه را در این قسمت بنویسید.

حمیدرضا کلباسی <hamidrezakalbasi@protonmail.com>

مهدی جعفری <mahdi.jfri.79@gmail.com>

میکائیل قربانی <mikaeelghr@gmail.com>

یاسین نوران <ynooran@gmail.com>

مقدمات

----------

>>‫ ‫‫اگر نکات اضافه‌ای در مورد تمرین یا برای دستیاران آموزشی دارید در این قسمت  ‫بنویسید.

>>‫ لطفا در این قسمت تمامی منابعی (غیر از مستندات Pintos، اسلاید‌ها و دیگر منابع‫ ‫درس) را که برای تمرین از آن‌ها استفاده کرده‌اید در این قسمت بنویسید.

بافر کش
============

داده‌ساختار‌ها و توابع
---------------------

>>‫ در این قسمت تعریف هر یک از `struct` ها، اعضای `struct` ها، متغیرهای سراسری یا ایستا، `typedef` ها یا `enum` هایی که ایجاد کرده‌اید یا تغییر داده‌اید را‫ بنویسید و دلیل هر کدام را در حداکثر ۲۵ کلمه توضیح دهید.

````

#define CACHE_BLOCK_COUNT 64 

struct cache_block {
    struct lock l;
    block_sector_t sector_id;
    bool valid;
    bool dirty;
    bool used;
    uint8_t data[BLOCK_SECTOR_SIZE];
}

int clock;

static struct cache_block cache_blocks[CACHE_BLOCK_COUNT];

struct lock global_cache_lock;

```


الگوریتم‌ها
------------

>>‫ توضیح دهید که الگوریتم مورد استفاده‌ی شما به چه صورت یک بلاک را برای جایگزین ‫ شدن انتخاب می‌کند؟

به روش NRU

>>‫ روش پیاده‌سازی `read-ahead` را توضیح دهید.



همگام سازی
-------------

>>‫ هنگامی که یک پردازه به طور مستمر در حال خواندن یا نوشتن داده در یک بلاک بافرکش‫ می‌باشد به چه صورت از دخالت سایر پردازه‌ها جلوگیری میشود؟

هر بلاک یک قفل دارد که آن پردازه هنگام کار با بلاک آن قفل را در اختیار دارد و بنابراین از دخالت سایر پردازه ها جلوگیری می شود.

>>‫ در حین خارج شدن یک بلوک از حافظه‌ی نهان، چگونه از پروسه‌های دیگر جلوگیری می‌شود تا‫ به این بلاک دسترسی پیدا نکنند؟

یک قفل کلی وجود دارد که هنگام خارج کردن یک بلوک، علاوه بر این که قفل خود بلوک گرفته می شود، آن قفل کلی نیز گرفته می شود تا کس دیگری این بلوک یا یک بلوک دیگر را هم زمان خارج نکند.

منطق طراحی
-----------------

>>‫ یک سناریو را توضیح دهید که از بافر کش، `read-ahead` و یا از `write-behind` استفاده کند.

فایل‌های قابل گسترش
=====================

داده‌ساختار‌ها و توابع
---------------------

>>‫ در این قسمت تعریف هر یک از `struct` ها، اعضای `struct` ها، متغیرهای سراسری‫ یا ایستا، `typedef` ها یا `enum` هایی که ایجاد کرده‌اید یا تغییر داده‌اید را بنویسید و‫ دلیل هر کدام را در حداکثر ۲۵ کلمه توضیح دهید.

```
struct inode_disk
  {
    int is_dir;
    off_t length;                       /* File size in bytes. */
    unsigned magic;                     /* Magic number. */
    block_sector_t children[123];               
    block_sector_t double_indirect, indirect;
  };

struct inode
  {
    struct list_elem elem;              /* Element in inode list. */
    block_sector_t sector;              /* Sector number of disk location. */
    int open_cnt;                       /* Number of openers. */
    bool removed;                       /* True if deleted, false otherwise. */
    int deny_write_cnt;                 /* 0: writes ok, >0: deny writes. */
    struct inode_disk data;             /* Inode content. */
    struct lock l;
  };
```


>>‫ بیشترین سایز فایل پشتیبانی شده توسط ساختار inode شما چقدر است؟
```
(123+128+128^2)*512=8517120
```


همگام سازی
----------

>>‫ توضیح دهید که اگر دو پردازه بخواهند یک فایل را به طور همزمان گسترش دهند، کد شما چگونه از‫ حالت مسابقه جلوگیری می‌کند.

همانطور که در بالا معلوم است به inode یک قفل اضافه کرده ایم که هنگام نوشتن در یک فایل، قفل inode آن فایل گرفته می شود و به این ترتیب دو نفر نمی توانند هم زمان یک فایل را گسترش دهند.

>>‫ فرض کنید دو پردازه‌ی A و B فایل F را باز کرده‌اند و هر دو به end-of-file اشاره کرده‌اند.‫ اگر  همزمان A از F بخواند و B روی آن بنویسد، ممکن است که A تمام، بخشی یا هیچ چیز از‫ اطلاعات نوشته شده توسط B را بخواند. همچنین A نمی‌تواند چیزی جز اطلاعات نوشته شده توسط B را‫ بخواند. مثلا اگر B تماما ۱ بنویسد، A نیز باید تماما ۱ بخواند. توضیح دهید کد شما چگونه از‫ این حالت مسابقه جلوگیری می‌کند.

هنگام خواندن و نوشتن، قفل inode مربوط به فایل گرفته می شود و به این ترتیب از حالت مسابقه جلوگیری می شود.

>>‫ توضیح دهید همگام سازی شما چگونه "عدالت" را برقرار می‌کند. فایل سیستمی "عادل" است که‫ خواننده‌های اطلاعات به صورت ناسازگار نویسنده‌های اطلاعات را مسدود نکنند و برعکس. بدین ترتیب‫ اگر تعدادی بسیار زیاد پردازه‌هایی که از یک فایل می‌خوانند نمی‌توانند تا ابد مانع نوشده شدن‫ اطلاعات توسط یک پردازه‌ی دیگر شوند و برعکس.

موقع باز کردن و بستن فایل قفل را نمی گیریم و فقط هنگام نوشتن و خواندن قفل را می گیریم که باعث می شود به صورت نوبتی نوبت به همه پردازه ها به ترتیب اولویتشان برسد و اگر قفل در حالت کلی مشکلی نداشته باشد، هنگام استفاده از فایل نیز مشکلی نخواهد بود و نوبت به همه می رسد.

منطق طراحی
----------

>>‫ آیا ساختار `inode` شما از طبقه‌بندی چند سطحه پشتیبانی می‌کند؟ اگر بله، دلیل خود را برای‫ انتخاب این ترکیب خاص از بلوک‌های مستقیم، غیر مستقیم و غیر مستقیم دوطرفه توضیح دهید.‌‫ اگر خیر، دلیل خود برای انتخاب ساختاری غیر از طبقه‌بندی چند سطحه و مزایا و معایب ساختار‫ مورد استفاده خود نسبت به طبقه‌بندی چند سطحه را توضیح دهید.

بله. ما از یک طبقه بندی دو سطحه استفاده کرده ایم که در عین سرعت زیاد، حجم قابل قبول (هشت مگابایت طبق داک طراحی قابل قبول است) را پشتیبانی می کند.

زیرمسیرها
============

داده‌ساختار‌ها و توابع
---------------------

>>‫ در این قسمت تعریف هر یک از `struct` ها، اعضای `struct` ها، متغیرهای سراسری‫ یا ایستا، `typedef` ها یا `enum` هایی که ایجاد کرده‌اید یا تغییر داده‌اید را بنویسید و‫ دلیل هر کدام را در حداکثر ۲۵ کلمه توضیح دهید.

```
struct inode_disk
  {
    int is_dir;
    off_t length;                       /* File size in bytes. */
    unsigned magic;                     /* Magic number. */
    block_sector_t children[123];               
    block_sector_t double_indirect, indirect;
  };

struct dir
  {
    struct inode *inode;                /* Backing store. */
    struct lock l;
    off_t pos;                          /* Current position. */
  };

struct thread
  {
    ..
    struct dir *cwd;
  }
```


الگوریتم‌ها
-----------

>>‫ کد خود را برای طی کردن یک مسیر گرفته‌شده از کاربر را توضیح دهید.‫ آیا عبور از مسیرهای absolute و relative تفاوتی دارد؟

ابتدا نقطه ابتدایی را معلوم می کنیم که اگر absolute باشد ریشه فایل سیستم و اگر relative باشد cwd خود پردازه است. سپس رشته ورودی را بر حسب اسلش جدا می کنیم و اگر حالت خاص . بود، هیچ کاری انجام نمی دهیم و در غیر این صورت، با تابع lookup آینود مربوط به دایرکتوری مخصوص را پیدا می کنیم. برای هر دایرکتوری یک entry با نام .. می گیریم که به پدر این دایرکتوری اشاره می کند و به این ترتیب مسیر های حاوی .. خود به خود هندل می شوند.

همگام سازی
-------------

>>‫ چگونه از رخ دادن race-condition در مورد دایرکتوری ها پیشگیری می‌کنید؟‫ برای مثال اگر دو درخواست موازی برای حذف یک فایل وجود داشته باشد و ‫ تنها یکی از آنها باید موفق شود یا مثلاً دو ریسه موازی بخواهند فایلی‫ یک اسم در یک مسیر ایجاد کنند و مانند آن.‫ آیا پیاده سازی شما اجازه می‌دهد مسیری که CWD یک ریسه شده یا پردازه‌ای‫ از آن استفاده می‌کند حذف شود؟ اگر بله، عملیات فایل سیستم بعدی روی آن‫ دایرکتوری چه نتیجه‌ای می‌دهند؟ اگر نه، چطور جلوی آن را می‌گیرید؟

هنگام لوکآپ و تغییر یک دایرکتوری و چک کردن `in_use` آن، قفل آن را می گیریم و تمام مشکلات مسابقه حل می شوند. هنگام حذف یک دایرکتوری یا فایل، آن را واقعا حذف نمی کنیم و صرفا `in_use`  آن و زیر درختش در فایل سیستم را false می کنیم. وقتی که از یک دایرکتوری استفاده می کنیم، ابتدا `in_use` آن را چک می کنیم و در صورت false بودن آن، به پدر آن می رویم. به این صورت، اجازه حذف شدن برای هر پوشه ای موجود است.

منطق طراحی
-----------------

>>‫ توضیح دهید چرا تصمیم گرفتید CWD یک پردازه را به شکلی که طراحی کرده‌اید‫ پیاده‌سازی کنید؟
اگر `char *` آن را می خواستیم نگه داریم، باید همیشه مسیر از ریشه تا این دایرکتوری را از دیسک می خواندیم اما اکنون آن را درون رم داریم.

### سوالات نظرسنجی

پاسخ به این سوالات دلخواه است، اما به ما برای بهبود این درس در ادامه کمک خواهد کرد.

نظرات خود را آزادانه به ما بگوئید—این سوالات فقط برای سنجش افکار شماست.

ممکن است شما بخواهید ارزیابی خود از درس را به صورت ناشناس و در انتهای ترم بیان کنید.

>>‫ به نظر شما، این تمرین گروهی، یا هر کدام از سه وظیفه آن، از نظر دشواری در چه سطحی بود؟ خیلی سخت یا خیلی آسان؟

>> چه مدت زمانی را صرف انجام این تمرین کردید؟ نسبتا زیاد یا خیلی کم؟

>>‫ آیا بعد از کار بر روی یک بخش خاص از این تمرین (هر بخشی)، این احساس در شما به وجود آمد که اکنون یک دید بهتر نسبت به برخی جنبه‌های سیستم عامل دارید؟

>>‫ آیا نکته یا راهنمایی خاصی وجود دارد که بهتر است ما آنها را به توضیحات این تمرین اضافه کنیم تا به دانشجویان ترم های آتی در حل مسائل کمک کند؟

>> متقابلا، آیا راهنمایی نادرستی که منجر به گمراهی شما شود وجود داشته است؟

>>‫ آیا پیشنهادی در مورد دستیاران آموزشی درس، برای همکاری موثرتر با دانشجویان دارید؟

این پیشنهادات میتوانند هم برای تمرین‌های گروهی بعدی همین ترم و هم برای ترم‌های آینده باشد.

>>‫ آیا حرف دیگری دارید؟